ğŸ§  What is SOLID?

SOLID is an acronym for five object-oriented design principles that help make code:

Easier to understand

Easier to maintain

Easier to extend

Less prone to bugs

Even though JavaScript isnâ€™t a class-based language by default (like Java or C#), ES6+ and TypeScript support classes and OOP â€” so SOLID applies directly.

âš™ï¸ SOLID stands for:

S â€“ Single Responsibility Principle

O â€“ Open/Closed Principle

L â€“ Liskov Substitution Principle

I â€“ Interface Segregation Principle

D â€“ Dependency Inversion Principle

Letâ€™s break them down with simple JavaScript examples ğŸ‘‡

ğŸŸ© 1. Single Responsibility Principle (SRP)

A class or module should have only one reason to change.

Each class or function should do one thing only.

âŒ Bad Example:

class User {
  saveUser(user) {
    // save user to DB
  }

  sendEmail(user) {
    // send welcome email
  }
}


Here, User handles both data persistence and email logic â†’ violates SRP.

âœ… Good Example:

class UserRepository {
  save(user) {
    // Save to DB
  }
}

class EmailService {
  sendWelcomeEmail(user) {
    // Send email
  }
}


Now, each class has one clear responsibility.

ğŸŸ¦ 2. Open/Closed Principle (OCP)

Software entities should be open for extension, but closed for modification.

You should be able to add new features without changing existing code.

âŒ Bad Example:

function getDiscount(type, amount) {
  if (type === "silver") return amount * 0.9;
  if (type === "gold") return amount * 0.8;
  if (type === "platinum") return amount * 0.7;
}


Adding a new type requires modifying the function â†’ violates OCP.

âœ… Good Example (Using Polymorphism):

class Discount {
  calc(amount) { return amount; }
}

class SilverDiscount extends Discount {
  calc(amount) { return amount * 0.9; }
}

class GoldDiscount extends Discount {
  calc(amount) { return amount * 0.8; }
}

function getDiscount(discountType, amount) {
  return discountType.calc(amount);
}

console.log(getDiscount(new GoldDiscount(), 100)); // 80


Now you can add new discount types without touching existing code.

ğŸŸ¨ 3. Liskov Substitution Principle (LSP)

Subclasses should be substitutable for their base classes without breaking functionality.

In simple terms â€” if class B inherits from class A, it should behave like A.

âŒ Bad Example:

class Bird {
  fly() { console.log("I can fly"); }
}

class Penguin extends Bird {
  fly() { throw new Error("I can't fly!"); }
}


Here, substituting a Penguin where a Bird is expected breaks code.

âœ… Good Example:

class Bird {
  move() { console.log("I can move"); }
}

class FlyingBird extends Bird {
  fly() { console.log("I can fly"); }
}

class Penguin extends Bird {
  swim() { console.log("I can swim"); }
}


Now both FlyingBird and Penguin honor LSP â€” no broken expectations.

ğŸŸ§ 4. Interface Segregation Principle (ISP)

Donâ€™t force a class to implement interfaces it doesnâ€™t use.

In JavaScript (no formal interfaces), this means:

Donâ€™t add unnecessary methods or props to a class.

Keep APIs small and focused.

âŒ Bad Example:

class Worker {
  work() {}
  eat() {}
}

class Robot extends Worker {
  eat() { throw new Error("Robots donâ€™t eat"); }
}


âœ… Good Example:

class Workable {
  work() {}
}

class Eatable {
  eat() {}
}

class Human extends Workable {
  eat() { console.log("Eating..."); }
}

class Robot extends Workable {}


Now each class only implements what it actually needs.

ğŸŸ¥ 5. Dependency Inversion Principle (DIP)

High-level modules shouldnâ€™t depend on low-level modules â€” both should depend on abstractions.

Instead of creating dependencies directly inside your class, inject them.

âŒ Bad Example:

class MySQL {
  connect() { console.log("Connected to MySQL"); }
}

class UserService {
  constructor() {
    this.db = new MySQL(); // tightly coupled
  }

  getUser() { this.db.connect(); }
}


âœ… Good Example (using Dependency Injection):

class MySQL {
  connect() { console.log("Connected to MySQL"); }
}

class MongoDB {
  connect() { console.log("Connected to MongoDB"); }
}

class UserService {
  constructor(database) {
    this.db = database; // inject dependency
  }

  getUser() { this.db.connect(); }
}

const service = new UserService(new MongoDB());
service.getUser(); // Connected to MongoDB


Now you can swap out databases without changing UserService.

ğŸ§© Summary
Principle	Meaning	JS Example
S	Single Responsibility	One class = one job
O	Open/Closed	Extend, donâ€™t modify
L	Liskov Substitution	Subclass should behave like parent
I	Interface Segregation	Keep APIs focused
D	Dependency Inversion	Depend on abstractions, not concrete classes



real world examples

Letâ€™s walk through a real-world Node.js example applying all SOLID principles together â€” using a simple User Management system.

Weâ€™ll design this so itâ€™s:

clean,

maintainable, and

easily extendable (without breaking anything).

ğŸ§© Goal

Weâ€™ll build a small example that:

Creates a user

Stores them in a database

Sends a welcome email

Weâ€™ll structure it using SOLID principles.

ğŸ—ï¸ 1. Start with the basic setup

Letâ€™s assume you have Node.js ES6 style classes.

ğŸŸ© S â€” Single Responsibility Principle

Each class should have one job only.

So weâ€™ll create:

UserRepository â†’ handles database operations

EmailService â†’ handles emails

UserService â†’ handles user-related business logic

// userRepository.js
class UserRepository {
  save(user) {
    console.log(`âœ… User ${user.name} saved to DB`);
  }
}

// emailService.js
class EmailService {
  sendWelcomeEmail(user) {
    console.log(`ğŸ“§ Email sent to ${user.email}`);
  }
}

ğŸŸ¦ O â€” Open/Closed Principle

We can easily extend functionality (e.g., support multiple databases or email providers)
without modifying existing classes.

// database interfaces
class MySQLRepository extends UserRepository {
  save(user) {
    console.log(`ğŸ’¾ [MySQL] Saved ${user.name}`);
  }
}

class MongoRepository extends UserRepository {
  save(user) {
    console.log(`ğŸ—„ï¸ [MongoDB] Saved ${user.name}`);
  }
}


Now you can add new database types without touching your main logic.

ğŸŸ¨ L â€” Liskov Substitution Principle

All repositories (MySQL, Mongo, etc.) behave the same way as UserRepository â€”
so UserService can use any of them interchangeably.

ğŸŸ§ I â€” Interface Segregation Principle

We wonâ€™t force a class to implement unnecessary behavior.

For example, EmailService only handles emails;
UserRepository only handles data;
they donâ€™t mix responsibilities.

ğŸŸ¥ D â€” Dependency Inversion Principle

Instead of UserService creating its own dependencies,
weâ€™ll inject them from the outside â€” making it flexible and testable.

// userService.js
class UserService {
  constructor(repository, emailService) {
    this.repository = repository;
    this.emailService = emailService;
  }

  createUser(user) {
    this.repository.save(user);
    this.emailService.sendWelcomeEmail(user);
  }
}

âš¡ Usage Example (Main File)
// main.js
import { MySQLRepository } from './mysqlRepository.js';
import { EmailService } from './emailService.js';
import { UserService } from './userService.js';

const db = new MySQLRepository();
const email = new EmailService();

const userService = new UserService(db, email);

const newUser = { name: "Firdous", email: "firdous@example.com" };

userService.createUser(newUser);

ğŸ§¾ Output:
ğŸ’¾ [MySQL] Saved Firdous
ğŸ“§ Email sent to firdous@example.com

ğŸŒŸ Why This Is SOLID
Principle	How Itâ€™s Applied
S	Each class has only one job (UserRepository, EmailService, UserService).
O	You can add new repositories or email providers without changing existing code.
L	Any subclass (e.g., MongoRepository) can replace the base repository.
I	Each class only exposes what it needs â€” no unnecessary methods.
D	Dependencies (DB, Email) are injected, not hardcoded.
ğŸ§  Bonus: Add a New Feature Without Changing Existing Code

If you want to add an SMS notification system:

class SmsService {
  sendSms(user) {
    console.log(`ğŸ“± SMS sent to ${user.name}`);
  }
}


Then just inject it into the constructor:

class UserService {
  constructor(repository, emailService, smsService) {
    this.repository = repository;
    this.emailService = emailService;
    this.smsService = smsService;
  }

  createUser(user) {
    this.repository.save(user);
    this.emailService.sendWelcomeEmail(user);
    this.smsService.sendSms(user);
  }
}


No existing classes modified â€” âœ… Open/Closed Principle respected.