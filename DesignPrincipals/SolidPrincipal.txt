🧠 What is SOLID?

SOLID is an acronym for five object-oriented design principles that help make code:

Easier to understand

Easier to maintain

Easier to extend

Less prone to bugs

Even though JavaScript isn’t a class-based language by default (like Java or C#), ES6+ and TypeScript support classes and OOP — so SOLID applies directly.

⚙️ SOLID stands for:

S – Single Responsibility Principle

O – Open/Closed Principle

L – Liskov Substitution Principle

I – Interface Segregation Principle

D – Dependency Inversion Principle

Let’s break them down with simple JavaScript examples 👇

🟩 1. Single Responsibility Principle (SRP)

A class or module should have only one reason to change.

Each class or function should do one thing only.

❌ Bad Example:

class User {
  saveUser(user) {
    // save user to DB
  }

  sendEmail(user) {
    // send welcome email
  }
}


Here, User handles both data persistence and email logic → violates SRP.

✅ Good Example:

class UserRepository {
  save(user) {
    // Save to DB
  }
}

class EmailService {
  sendWelcomeEmail(user) {
    // Send email
  }
}


Now, each class has one clear responsibility.

🟦 2. Open/Closed Principle (OCP)

Software entities should be open for extension, but closed for modification.

You should be able to add new features without changing existing code.

❌ Bad Example:

function getDiscount(type, amount) {
  if (type === "silver") return amount * 0.9;
  if (type === "gold") return amount * 0.8;
  if (type === "platinum") return amount * 0.7;
}


Adding a new type requires modifying the function → violates OCP.

✅ Good Example (Using Polymorphism):

class Discount {
  calc(amount) { return amount; }
}

class SilverDiscount extends Discount {
  calc(amount) { return amount * 0.9; }
}

class GoldDiscount extends Discount {
  calc(amount) { return amount * 0.8; }
}

function getDiscount(discountType, amount) {
  return discountType.calc(amount);
}

console.log(getDiscount(new GoldDiscount(), 100)); // 80


Now you can add new discount types without touching existing code.

🟨 3. Liskov Substitution Principle (LSP)

Subclasses should be substitutable for their base classes without breaking functionality.

In simple terms — if class B inherits from class A, it should behave like A.

❌ Bad Example:

class Bird {
  fly() { console.log("I can fly"); }
}

class Penguin extends Bird {
  fly() { throw new Error("I can't fly!"); }
}


Here, substituting a Penguin where a Bird is expected breaks code.

✅ Good Example:

class Bird {
  move() { console.log("I can move"); }
}

class FlyingBird extends Bird {
  fly() { console.log("I can fly"); }
}

class Penguin extends Bird {
  swim() { console.log("I can swim"); }
}


Now both FlyingBird and Penguin honor LSP — no broken expectations.

🟧 4. Interface Segregation Principle (ISP)

Don’t force a class to implement interfaces it doesn’t use.

In JavaScript (no formal interfaces), this means:

Don’t add unnecessary methods or props to a class.

Keep APIs small and focused.

❌ Bad Example:

class Worker {
  work() {}
  eat() {}
}

class Robot extends Worker {
  eat() { throw new Error("Robots don’t eat"); }
}


✅ Good Example:

class Workable {
  work() {}
}

class Eatable {
  eat() {}
}

class Human extends Workable {
  eat() { console.log("Eating..."); }
}

class Robot extends Workable {}


Now each class only implements what it actually needs.

🟥 5. Dependency Inversion Principle (DIP)

High-level modules shouldn’t depend on low-level modules — both should depend on abstractions.

Instead of creating dependencies directly inside your class, inject them.

❌ Bad Example:

class MySQL {
  connect() { console.log("Connected to MySQL"); }
}

class UserService {
  constructor() {
    this.db = new MySQL(); // tightly coupled
  }

  getUser() { this.db.connect(); }
}


✅ Good Example (using Dependency Injection):

class MySQL {
  connect() { console.log("Connected to MySQL"); }
}

class MongoDB {
  connect() { console.log("Connected to MongoDB"); }
}

class UserService {
  constructor(database) {
    this.db = database; // inject dependency
  }

  getUser() { this.db.connect(); }
}

const service = new UserService(new MongoDB());
service.getUser(); // Connected to MongoDB


Now you can swap out databases without changing UserService.

🧩 Summary
Principle	Meaning	JS Example
S	Single Responsibility	One class = one job
O	Open/Closed	Extend, don’t modify
L	Liskov Substitution	Subclass should behave like parent
I	Interface Segregation	Keep APIs focused
D	Dependency Inversion	Depend on abstractions, not concrete classes



real world examples

Let’s walk through a real-world Node.js example applying all SOLID principles together — using a simple User Management system.

We’ll design this so it’s:

clean,

maintainable, and

easily extendable (without breaking anything).

🧩 Goal

We’ll build a small example that:

Creates a user

Stores them in a database

Sends a welcome email

We’ll structure it using SOLID principles.

🏗️ 1. Start with the basic setup

Let’s assume you have Node.js ES6 style classes.

🟩 S — Single Responsibility Principle

Each class should have one job only.

So we’ll create:

UserRepository → handles database operations

EmailService → handles emails

UserService → handles user-related business logic

// userRepository.js
class UserRepository {
  save(user) {
    console.log(`✅ User ${user.name} saved to DB`);
  }
}

// emailService.js
class EmailService {
  sendWelcomeEmail(user) {
    console.log(`📧 Email sent to ${user.email}`);
  }
}

🟦 O — Open/Closed Principle

We can easily extend functionality (e.g., support multiple databases or email providers)
without modifying existing classes.

// database interfaces
class MySQLRepository extends UserRepository {
  save(user) {
    console.log(`💾 [MySQL] Saved ${user.name}`);
  }
}

class MongoRepository extends UserRepository {
  save(user) {
    console.log(`🗄️ [MongoDB] Saved ${user.name}`);
  }
}


Now you can add new database types without touching your main logic.

🟨 L — Liskov Substitution Principle

All repositories (MySQL, Mongo, etc.) behave the same way as UserRepository —
so UserService can use any of them interchangeably.

🟧 I — Interface Segregation Principle

We won’t force a class to implement unnecessary behavior.

For example, EmailService only handles emails;
UserRepository only handles data;
they don’t mix responsibilities.

🟥 D — Dependency Inversion Principle

Instead of UserService creating its own dependencies,
we’ll inject them from the outside — making it flexible and testable.

// userService.js
class UserService {
  constructor(repository, emailService) {
    this.repository = repository;
    this.emailService = emailService;
  }

  createUser(user) {
    this.repository.save(user);
    this.emailService.sendWelcomeEmail(user);
  }
}

⚡ Usage Example (Main File)
// main.js
import { MySQLRepository } from './mysqlRepository.js';
import { EmailService } from './emailService.js';
import { UserService } from './userService.js';

const db = new MySQLRepository();
const email = new EmailService();

const userService = new UserService(db, email);

const newUser = { name: "Firdous", email: "firdous@example.com" };

userService.createUser(newUser);

🧾 Output:
💾 [MySQL] Saved Firdous
📧 Email sent to firdous@example.com

🌟 Why This Is SOLID
Principle	How It’s Applied
S	Each class has only one job (UserRepository, EmailService, UserService).
O	You can add new repositories or email providers without changing existing code.
L	Any subclass (e.g., MongoRepository) can replace the base repository.
I	Each class only exposes what it needs — no unnecessary methods.
D	Dependencies (DB, Email) are injected, not hardcoded.
🧠 Bonus: Add a New Feature Without Changing Existing Code

If you want to add an SMS notification system:

class SmsService {
  sendSms(user) {
    console.log(`📱 SMS sent to ${user.name}`);
  }
}


Then just inject it into the constructor:

class UserService {
  constructor(repository, emailService, smsService) {
    this.repository = repository;
    this.emailService = emailService;
    this.smsService = smsService;
  }

  createUser(user) {
    this.repository.save(user);
    this.emailService.sendWelcomeEmail(user);
    this.smsService.sendSms(user);
  }
}


No existing classes modified — ✅ Open/Closed Principle respected.