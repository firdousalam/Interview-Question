Top React Design Patterns (2025-Ready)

We’ll organize them into 3 levels:

Level	Type	Description
🧩 Component Patterns	Reusable building blocks	Optimize component logic
🔄 State & Logic Patterns	Manage data flow	Improve scalability
🏗️ Architectural Patterns	Project structure	Improve maintainability
🧩 1. Container–Presentational Pattern
💡 Concept:

Split components into:

Presentational components (UI only)

Container components (business logic, data fetching)

🧠 Why:

Keeps UI simple and testable, while containers handle side effects.

🧩 Example:
// UserListContainer.jsx
import React, { useEffect, useState } from "react";
import UserList from "./UserList";

export default function UserListContainer() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch("/api/users").then(res => res.json()).then(setUsers);
  }, []);

  return <UserList users={users} />;
}

// UserList.jsx
export default function UserList({ users }) {
  return (
    <ul>
      {users.map(u => <li key={u.id}>{u.name}</li>)}
    </ul>
  );
}


✅ Advantages:

Separation of concerns

Easy to test UI components

Reusable across contexts

🧩 2. Higher-Order Component (HOC) Pattern
💡 Concept:

A function that takes a component and returns a new component with added functionality.

🧩 Example:
function withLogger(WrappedComponent) {
  return function(props) {
    console.log(`Rendering ${WrappedComponent.name}`);
    return <WrappedComponent {...props} />;
  };
}

function Button(props) {
  return <button>{props.label}</button>;
}

const LoggedButton = withLogger(Button);


✅ Use case:
Cross-cutting concerns like logging, permissions, analytics, etc.

⚠️ HOCs are older; Hooks often replace them now.

🧩 3. Render Props Pattern
💡 Concept:

Share logic between components using a function as a child.

🧩 Example:
function DataFetcher({ url, children }) {
  const [data, setData] = React.useState([]);

  React.useEffect(() => {
    fetch(url).then(res => res.json()).then(setData);
  }, [url]);

  return children(data);
}

// Usage
<DataFetcher url="/api/users">
  {data => <UserList users={data} />}
</DataFetcher>


✅ Use case:
When multiple components need to share logic but render differently.

⚠️ Often replaced by custom hooks now.

🧩 4. Custom Hooks Pattern
💡 Concept:

Encapsulate reusable logic (e.g. fetching, auth, form handling) in a custom hook.

🧩 Example:
function useFetch(url) {
  const [data, setData] = React.useState(null);
  React.useEffect(() => {
    fetch(url).then(res => res.json()).then(setData);
  }, [url]);
  return data;
}

// Usage
function UserList() {
  const users = useFetch("/api/users");
  return users ? users.map(u => <div>{u.name}</div>) : "Loading...";
}


✅ Use case:
Reusing side effects and logic cleanly.
💥 The most used pattern in modern React.

🧩 5. Controlled vs Uncontrolled Components
💡 Concept:

Controlled: React fully manages the component state.

Uncontrolled: DOM handles the state (using ref).

🧩 Example:
// Controlled
<input value={name} onChange={(e) => setName(e.target.value)} />

// Uncontrolled
<input ref={inputRef} />


✅ Use case:
Controlled = forms with validations
Uncontrolled = simple, performance-focused inputs

🧩 6. Compound Components Pattern
💡 Concept:

Let child components communicate implicitly through React context.

🧩 Example:
const TabsContext = React.createContext();

function Tabs({ children }) {
  const [active, setActive] = React.useState(0);
  return (
    <TabsContext.Provider value={{ active, setActive }}>
      {children}
    </TabsContext.Provider>
  );
}

function TabList({ children }) {
  return <div>{children}</div>;
}

function Tab({ index, children }) {
  const { active, setActive } = React.useContext(TabsContext);
  return (
    <button onClick={() => setActive(index)} style={{ fontWeight: active === index ? "bold" : "normal" }}>
      {children}
    </button>
  );
}

function TabPanels({ children }) {
  const { active } = React.useContext(TabsContext);
  return <div>{children[active]}</div>;
}

// Usage
<Tabs>
  <TabList>
    <Tab index={0}>Home</Tab>
    <Tab index={1}>Profile</Tab>
  </TabList>
  <TabPanels>
    <div>Home content</div>
    <div>Profile content</div>
  </TabPanels>
</Tabs>


✅ Use case:
Reusable components like Tabs, Dropdown, Accordion.

🧩 7. Context + Provider Pattern
💡 Concept:

Share global state (theme, auth, language) across the component tree.

🧩 Example:
const ThemeContext = React.createContext();

export function ThemeProvider({ children }) {
  const [theme, setTheme] = React.useState("light");
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  return React.useContext(ThemeContext);
}


✅ Use case:
Global state, user authentication, theming.

🔄 8. Observer / Pub–Sub Pattern (State Management)
💡 Concept:

React state managers (like Redux, Zustand, Recoil) use observer pattern under the hood.

Example (Redux style):
store.subscribe(() => {
  console.log("State updated:", store.getState());
});


✅ Use case:
Global app state that updates multiple components automatically.

🧩 9. Lazy Loading & Code Splitting Pattern
💡 Concept:

Load components only when needed to improve performance.

🧩 Example:
const UserProfile = React.lazy(() => import("./UserProfile"));

function App() {
  return (
    <React.Suspense fallback={<div>Loading...</div>}>
      <UserProfile />
    </React.Suspense>
  );
}


✅ Use case:
Large-scale apps — improves load time and UX.

🏗️ 10. Flux / Redux Architecture Pattern
💡 Concept:

Unidirectional data flow:

Action → Dispatcher → Store → View

🧩 Example Flow:

Component dispatches an action

Action updates the store

View re-renders automatically

✅ Use case:
Complex apps requiring predictable state flow (e.g., dashboards, admin panels).

⚙️ Bonus Patterns (Advanced React)
Pattern	Use Case
Hooks Composition	Combine multiple hooks into one custom hook
Error Boundary Pattern	Handle runtime UI errors gracefully
Suspense Pattern	Declarative async UI loading
Portal Pattern	Render modals/tooltips outside parent DOM tree
Atomic Design Pattern	Structure UI by atoms → molecules → organisms
🧭 Summary Table
Category	Pattern	Purpose
Component	Container-Presentational	Separate logic and UI
Component	Compound Components	Context-based child communication
Logic	Custom Hooks	Reusable side-effect logic
Logic	Render Props / HOC	Reuse component logic
State	Context Provider	Global shared state
Architecture	Flux / Redux	Predictable state management
UI	Lazy Loading / Suspense	Performance optimization