Top React Design Patterns (2025-Ready)

Weâ€™ll organize them into 3 levels:

Level	Type	Description
ğŸ§© Component Patterns	Reusable building blocks	Optimize component logic
ğŸ”„ State & Logic Patterns	Manage data flow	Improve scalability
ğŸ—ï¸ Architectural Patterns	Project structure	Improve maintainability
ğŸ§© 1. Containerâ€“Presentational Pattern
ğŸ’¡ Concept:

Split components into:

Presentational components (UI only)

Container components (business logic, data fetching)

ğŸ§  Why:

Keeps UI simple and testable, while containers handle side effects.

ğŸ§© Example:
// UserListContainer.jsx
import React, { useEffect, useState } from "react";
import UserList from "./UserList";

export default function UserListContainer() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch("/api/users").then(res => res.json()).then(setUsers);
  }, []);

  return <UserList users={users} />;
}

// UserList.jsx
export default function UserList({ users }) {
  return (
    <ul>
      {users.map(u => <li key={u.id}>{u.name}</li>)}
    </ul>
  );
}


âœ… Advantages:

Separation of concerns

Easy to test UI components

Reusable across contexts

ğŸ§© 2. Higher-Order Component (HOC) Pattern
ğŸ’¡ Concept:

A function that takes a component and returns a new component with added functionality.

ğŸ§© Example:
function withLogger(WrappedComponent) {
  return function(props) {
    console.log(`Rendering ${WrappedComponent.name}`);
    return <WrappedComponent {...props} />;
  };
}

function Button(props) {
  return <button>{props.label}</button>;
}

const LoggedButton = withLogger(Button);


âœ… Use case:
Cross-cutting concerns like logging, permissions, analytics, etc.

âš ï¸ HOCs are older; Hooks often replace them now.

ğŸ§© 3. Render Props Pattern
ğŸ’¡ Concept:

Share logic between components using a function as a child.

ğŸ§© Example:
function DataFetcher({ url, children }) {
  const [data, setData] = React.useState([]);

  React.useEffect(() => {
    fetch(url).then(res => res.json()).then(setData);
  }, [url]);

  return children(data);
}

// Usage
<DataFetcher url="/api/users">
  {data => <UserList users={data} />}
</DataFetcher>


âœ… Use case:
When multiple components need to share logic but render differently.

âš ï¸ Often replaced by custom hooks now.

ğŸ§© 4. Custom Hooks Pattern
ğŸ’¡ Concept:

Encapsulate reusable logic (e.g. fetching, auth, form handling) in a custom hook.

ğŸ§© Example:
function useFetch(url) {
  const [data, setData] = React.useState(null);
  React.useEffect(() => {
    fetch(url).then(res => res.json()).then(setData);
  }, [url]);
  return data;
}

// Usage
function UserList() {
  const users = useFetch("/api/users");
  return users ? users.map(u => <div>{u.name}</div>) : "Loading...";
}


âœ… Use case:
Reusing side effects and logic cleanly.
ğŸ’¥ The most used pattern in modern React.

ğŸ§© 5. Controlled vs Uncontrolled Components
ğŸ’¡ Concept:

Controlled: React fully manages the component state.

Uncontrolled: DOM handles the state (using ref).

ğŸ§© Example:
// Controlled
<input value={name} onChange={(e) => setName(e.target.value)} />

// Uncontrolled
<input ref={inputRef} />


âœ… Use case:
Controlled = forms with validations
Uncontrolled = simple, performance-focused inputs

ğŸ§© 6. Compound Components Pattern
ğŸ’¡ Concept:

Let child components communicate implicitly through React context.

ğŸ§© Example:
const TabsContext = React.createContext();

function Tabs({ children }) {
  const [active, setActive] = React.useState(0);
  return (
    <TabsContext.Provider value={{ active, setActive }}>
      {children}
    </TabsContext.Provider>
  );
}

function TabList({ children }) {
  return <div>{children}</div>;
}

function Tab({ index, children }) {
  const { active, setActive } = React.useContext(TabsContext);
  return (
    <button onClick={() => setActive(index)} style={{ fontWeight: active === index ? "bold" : "normal" }}>
      {children}
    </button>
  );
}

function TabPanels({ children }) {
  const { active } = React.useContext(TabsContext);
  return <div>{children[active]}</div>;
}

// Usage
<Tabs>
  <TabList>
    <Tab index={0}>Home</Tab>
    <Tab index={1}>Profile</Tab>
  </TabList>
  <TabPanels>
    <div>Home content</div>
    <div>Profile content</div>
  </TabPanels>
</Tabs>


âœ… Use case:
Reusable components like Tabs, Dropdown, Accordion.

ğŸ§© 7. Context + Provider Pattern
ğŸ’¡ Concept:

Share global state (theme, auth, language) across the component tree.

ğŸ§© Example:
const ThemeContext = React.createContext();

export function ThemeProvider({ children }) {
  const [theme, setTheme] = React.useState("light");
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  return React.useContext(ThemeContext);
}


âœ… Use case:
Global state, user authentication, theming.

ğŸ”„ 8. Observer / Pubâ€“Sub Pattern (State Management)
ğŸ’¡ Concept:

React state managers (like Redux, Zustand, Recoil) use observer pattern under the hood.

Example (Redux style):
store.subscribe(() => {
  console.log("State updated:", store.getState());
});


âœ… Use case:
Global app state that updates multiple components automatically.

ğŸ§© 9. Lazy Loading & Code Splitting Pattern
ğŸ’¡ Concept:

Load components only when needed to improve performance.

ğŸ§© Example:
const UserProfile = React.lazy(() => import("./UserProfile"));

function App() {
  return (
    <React.Suspense fallback={<div>Loading...</div>}>
      <UserProfile />
    </React.Suspense>
  );
}


âœ… Use case:
Large-scale apps â€” improves load time and UX.

ğŸ—ï¸ 10. Flux / Redux Architecture Pattern
ğŸ’¡ Concept:

Unidirectional data flow:

Action â†’ Dispatcher â†’ Store â†’ View

ğŸ§© Example Flow:

Component dispatches an action

Action updates the store

View re-renders automatically

âœ… Use case:
Complex apps requiring predictable state flow (e.g., dashboards, admin panels).

âš™ï¸ Bonus Patterns (Advanced React)
Pattern	Use Case
Hooks Composition	Combine multiple hooks into one custom hook
Error Boundary Pattern	Handle runtime UI errors gracefully
Suspense Pattern	Declarative async UI loading
Portal Pattern	Render modals/tooltips outside parent DOM tree
Atomic Design Pattern	Structure UI by atoms â†’ molecules â†’ organisms
ğŸ§­ Summary Table
Category	Pattern	Purpose
Component	Container-Presentational	Separate logic and UI
Component	Compound Components	Context-based child communication
Logic	Custom Hooks	Reusable side-effect logic
Logic	Render Props / HOC	Reuse component logic
State	Context Provider	Global shared state
Architecture	Flux / Redux	Predictable state management
UI	Lazy Loading / Suspense	Performance optimization